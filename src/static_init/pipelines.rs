// Need an enum generated by macro from the source & sink enums.

use std::any::TypeId;
use std::collections::HashMap;

use crate::core::pipeline::{ExecutablePipeline, Pipeline};
use crate::domain::config::{Config, TranslatorConfig};
use crate::domain::entity_data::EntityData;
use crate::domain::entity_translator::{EntityTranslator, TranslationDescription};
use crate::domain::entity_user::EntityUser;
use crate::domain::sink::Sink;
use crate::domain::source::Source;
use crate::integration::log::sink::LogSink;
use crate::integration::stub::source::StubSource;
use crate::static_init::sinks::Sinks;
use crate::static_init::sources::Sources;
use crate::static_init::translators::Translators::NoOp;
use crate::static_init::translators::{Translators, SUPPORTED_TYPES};

pub(crate) fn create_pipelines<'a, ConfigType>(
    config: &'a ConfigType,
    sources: &'a [Sources],
    sinks: &'a HashMap<&str, Sinks>,
    translators: &'a HashMap<TranslationDescription, Translators>,
) -> Vec<Box<dyn ExecutablePipeline + 'a>>
where
    ConfigType: Config,
{
    let mut pipelines: Vec<Box<dyn ExecutablePipeline>> = Vec::new();

    for pipeline in config.pipelines() {
        let source = sources
            .iter()
            .find(|source| source.identifier().unique_name() == pipeline.source())
            .unwrap_or_else(|| panic!("Missing source: {}", pipeline.source()));
        let sink = sinks
            .get(pipeline.sink())
            .unwrap_or_else(|| panic!("Missing sink: {}", pipeline.sink()));
        let translator = translators
            .get_translator(pipeline.translator(), source, sink)
            .unwrap_or_else(|| {
                panic!(
                    "Missing translator from source: {from}, to sink: {to}",
                    from = pipeline.source(),
                    to = pipeline.sink()
                )
            });
        pipelines.push(with_translators(translator, source, sink));
    }

    pipelines
}

fn with_translators<'a>(
    translator: &'a Translators,
    source: &'a Sources,
    sink: &'a Sinks,
) -> Box<dyn ExecutablePipeline + 'a> {
    match translator {
        NoOp => {
            let it: Box<dyn ExecutablePipeline> = noop_translator(source, sink);
            it
        }
        Translators::UuidToString(implementation) => {
            let it: Box<dyn ExecutablePipeline> = with_translator(
                implementation.as_ref().expect("Could not get translator"),
                source,
                sink,
            );
            it
        }
    }
}

fn with_translator<'a, FromType, ToType, TranslatorType>(
    translator: &'a TranslatorType,
    sources: &'a Sources,
    sinks: &'a Sinks,
) -> Box<dyn ExecutablePipeline + 'a>
where
    FromType: EntityData,
    LogSink: Sink<ToType>,
    StubSource: Source<FromType>,
    ToType: EntityData,
    TranslatorType: EntityTranslator<FromType, ToType>,
{
    match sources {
        Sources::Stub(implementation) => translator_with_source(
            translator,
            implementation.as_ref().expect("Could not get source"),
            sinks,
        ),
    }
}

fn translator_with_source<'a, FromType, SourceType, ToType, TranslatorType>(
    translator: &'a TranslatorType,
    source: &'a SourceType,
    sink: &'a Sinks,
) -> Box<dyn ExecutablePipeline + 'a>
where
    FromType: EntityData,
    LogSink: Sink<ToType>,
    SourceType: Source<FromType>,
    ToType: EntityData,
    TranslatorType: EntityTranslator<FromType, ToType> + 'a,
{
    match sink {
        Sinks::Log(implementation) => translator_with_sink(translator, source, implementation),
    }
}

fn translator_with_sink<'a, 'b, FromType, SinkType, SourceType, ToType, TranslatorType>(
    translator: &'a TranslatorType,
    source: &'b SourceType,
    sink: &'b SinkType,
) -> Box<dyn ExecutablePipeline + 'b>
where
    FromType: EntityData,
    LogSink: Sink<ToType>,
    SinkType: Sink<ToType>,
    SourceType: Source<FromType>,
    ToType: EntityData,
    TranslatorType: EntityTranslator<FromType, ToType> + 'b,
{
    Pipeline::new(source, translator.clone(), sink)
}

fn noop_translator<'a>(source: &'a Sources, sinks: &'a Sinks) -> Box<dyn ExecutablePipeline + 'a> {
    let could_not_get_source = "Could not get source";
    match source {
        Sources::Stub(implementation) => {
            noop_translator_with_source(implementation.as_ref().expect(could_not_get_source), sinks)
        }
    }
}

fn noop_translator_with_source<'a, DataType, SourceType>(
    source: &'a SourceType,
    sinks: &'a Sinks,
) -> Box<dyn ExecutablePipeline + 'a>
where
    SourceType: Source<DataType>,
    DataType: EntityData,
    LogSink: Sink<DataType>,
{
    match sinks {
        Sinks::Log(implementation) => noop_translator_with_sink(source, implementation),
    }
}

fn noop_translator_with_sink<'a, DataType, SinkType, SourceType>(
    source: &'a SourceType,
    sink: &'a SinkType,
) -> Box<dyn ExecutablePipeline + 'a>
where
    DataType: EntityData,
    SinkType: Sink<DataType>,
    SourceType: Source<DataType>,
{
    Pipeline::new_no_op(source, sink)
}

trait TranslatorGetter {
    fn get_translator(
        &self,
        translator_spec: Option<&TranslatorConfig>,
        source: &Sources,
        sink: &Sinks,
    ) -> Option<&Translators>;
}

impl TranslatorGetter for HashMap<TranslationDescription, Translators> {
    fn get_translator(
        &self,
        translator_spec: Option<&TranslatorConfig>,
        source: &Sources,
        sink: &Sinks,
    ) -> Option<&Translators> {
        if let Some(translator_config) = translator_spec {
            let from_type_id = SUPPORTED_TYPES
                .get(translator_config.from())
                .expect("Could not find from type")
                .clone();
            let to_type_id = SUPPORTED_TYPES
                .get(translator_config.to())
                .expect("Could not find to type")
                .clone();
            let translation_description = TranslationDescription {
                from: from_type_id,
                to: to_type_id,
            };
            return self.get(&translation_description);
        }

        let from_list: Vec<TypeId> = match source {
            Sources::Stub(instance) => instance.as_ref()?.this_supports_entity_data(),
        };

        let to_list: Vec<TypeId> = match sink {
            Sinks::Log(instance) => instance.this_supports_entity_data(),
        };

        if from_list
            .iter()
            .find(|from| to_list.contains(from))
            .is_some()
        {
            return Some(&NoOp);
        }

        for from in from_list.iter() {
            for to in to_list.iter() {
                let translation_description = TranslationDescription {
                    from: *from,
                    to: *to,
                };
                if let Some(translator) = self.get(&translation_description) {
                    return Some(translator);
                }
            }
        }

        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::core::config::Config as CoreConfig;
    use crate::static_init::sinks::create_sinks;
    use crate::static_init::sources::create_sources;
    use crate::static_init::translators::create_translators;

    #[test]
    fn get_translator_instantiates_when_no_direct_spec() {
        let config = CoreConfig::new();

        let sources = create_sources(config.as_ref());
        let sinks = create_sinks(config.as_ref());
        let translators = create_translators();

        let pipelines = create_pipelines(config.as_ref(), &sources, &sinks, &translators);

        assert_eq!(pipelines.len(), 1);
    }
}
